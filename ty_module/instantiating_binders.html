<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Instantiating binders - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/main/src/ty_module/instantiating_binders.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="instantiating-binders"><a class="header" href="#instantiating-binders">Instantiating <code>Binder</code>s</a></h1>
<p>Much like <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.EarlyBinder.html"><code>EarlyBinder</code></a>, when accessing the inside of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/type.Binder.html"><code>Binder</code></a> we must first discharge it by replacing the bound vars with some other value. This is for much the same reason as with <code>EarlyBinder</code>, types referencing parameters introduced by the <code>Binder</code> do not make any sense outside of that binder, for example:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a&gt;(a: &amp;'a u32) -&gt; &amp;'a u32 {
    a
}
fn bar&lt;T&gt;(a: fn(&amp;u32) -&gt; T) -&gt; T {
    a(&amp;10)
}

fn main() {
    let higher_ranked_fn_ptr = foo as for&lt;'a&gt; fn(&amp;'a u32) -&gt; &amp;'a u32;
    let references_bound_vars = bar(higher_ranked_fn_ptr);
}</code></pre>
<p>In this example we are providing an argument of type <code>for&lt;'a&gt; fn(&amp;'^0 u32) -&gt; &amp;'^0 u32</code> to <code>bar</code>, we do not want to allow <code>T</code> to be inferred to the type <code>&amp;'^0 u32</code> as it would be rather nonsensical (and likely unsound if we did not happen to ICE, <code>main</code> has no idea what <code>'a</code> is so how would the borrow checker handle a borrow with lifetime <code>'a</code>).</p>
<p>Unlike <code>EarlyBinder</code> we typically do not instantiate <code>Binder</code> with some concrete set of arguments from the user, i.e. <code>['b, 'static]</code> as arguments to a <code>for&lt;'a1, 'a2&gt; fn(&amp;'a1 u32, &amp;'a2 u32)</code>. Instead we usually instantiate the binder with inference variables or placeholders.</p>
<h2 id="instantiating-with-inference-variables"><a class="header" href="#instantiating-with-inference-variables">Instantiating with inference variables</a></h2>
<p>We instantiate binders with inference variables when we are trying to infer a possible instantiation of the binder, e.g. calling higher ranked function pointers or attempting to use a higher ranked where-clause to prove some bound. For example, given the <code>higher_ranked_fn_ptr</code> from the example above, if we were to call it with <code>&amp;10_u32</code> we would:</p>
<ul>
<li>Instantiate the binder with infer vars yielding a signature of <code>fn(&amp;'?0 u32) -&gt; &amp;'?0 u32)</code></li>
<li>Equate the type of the provided argument <code>&amp;10_u32</code> (&amp;'static u32) with the type in the signature, <code>&amp;'?0 u32</code>, inferring <code>'?0 = 'static</code></li>
<li>The provided arguments were correct as we were successfully able to unify the types of the provided arguments with the types of the arguments in fn ptr signature</li>
</ul>
<p>As another example of instantiating with infer vars, given some <code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code> where-clause, if we were attempting to prove that <code>T: Trait&lt;'static&gt;</code> holds we would:</p>
<ul>
<li>Instantiate the binder with infer vars yielding a where clause of <code>T: Trait&lt;'?0&gt;</code></li>
<li>Equate the goal of <code>T: Trait&lt;'static&gt;</code> with the instantiated where clause, inferring <code>'?0 = 'static</code></li>
<li>The goal holds because we were successfully able to unify <code>T: Trait&lt;'static&gt;</code> with <code>T: Trait&lt;'?0&gt;</code></li>
</ul>
<p>Instantiating binders with inference variables can be accomplished by using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/infer/struct.InferCtxt.html#method.instantiate_binder_with_fresh_vars"><code>instantiate_binder_with_fresh_vars</code></a> method on <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/infer/struct.InferCtxt.html"><code>InferCtxt</code></a>. Binders should be instantiated with infer vars when we only care about one specific instantiation of the binder, if instead we wish to reason about all possible instantiations of the binder then placeholders should be used instead.</p>
<h2 id="instantiating-with-placeholders"><a class="header" href="#instantiating-with-placeholders">Instantiating with placeholders</a></h2>
<p>Placeholders are very similar to <code>Ty/ConstKind::Param</code>/<code>ReEarlyParam</code>, they represent some unknown type that is only equal to itself. <code>Ty</code>/<code>Const</code> and <code>Region</code> all have a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Placeholder.html"><code>Placeholder</code></a> variant that is comprised of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.UniverseIndex.html"><code>Universe</code></a> and a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.BoundVar.html"><code>BoundVar</code></a>.</p>
<p>The <code>Universe</code> tracks which binder the placeholder originated from, and the <code>BoundVar</code> tracks which parameter on said binder that this placeholder corresponds to. Equality of placeholders is determined solely by whether the universes are equal and the <code>BoundVar</code>s are equal. See the <a href="../borrow_check/region_inference/placeholders_and_universes.html">chapter on Placeholders and Universes</a> for more information.</p>
<p>When talking with other rustc devs or seeing <code>Debug</code> formatted <code>Ty</code>/<code>Const</code>/<code>Region</code>s, <code>Placeholder</code> will often be written as <code>'!UNIVERSE_BOUNDVARS</code>. For example given some type <code>for&lt;'a&gt; fn(&amp;'a u32, for&lt;'b&gt; fn(&amp;'b &amp;'a u32))</code>, after instantiating both binders (assuming the <code>Universe</code> in the current <code>InferCtxt</code> was <code>U0</code> beforehand), the type of <code>&amp;'b &amp;'a u32</code> would be represented as <code>&amp;'!2_0 &amp;!1_0 u32</code>.</p>
<p>When the universe of the placeholder is <code>0</code>, it will be entirely omitted from the debug output, i.e. <code>!0_2</code> would be printed as <code>!2</code>. This rarely happens in practice though as we increase the universe in the <code>InferCtxt</code> when instantiating a binder with placeholders so usually the lowest universe placeholders encounterable are ones in <code>U1</code>.</p>
<p><code>Binder</code>s can be instantiated with placeholders via the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/infer/struct.InferCtxt.html#method.enter_forall"><code>enter_forall</code></a> method on <code>InferCtxt</code>. It should be used whenever the compiler should care about any possible instantiation of the binder instead of one concrete instantiation.</p>
<p>Note: in the original example of this chapter it was mentioned that we should not infer a local variable to have type <code>&amp;'^0 u32</code>. This code is prevented from compiling via universes (as explained in the linked chapter)</p>
<h3 id="why-have-both-replaceholder-and-rebound"><a class="header" href="#why-have-both-replaceholder-and-rebound">Why have both <code>RePlaceholder</code> and <code>ReBound</code>?</a></h3>
<p>You may be wondering why we have both of these variants, afterall the data stored in <code>Placeholder</code> is effectively equivalent to that of <code>ReBound</code>: something to track which binder, and an index to track which parameter the <code>Binder</code> introduced.</p>
<p>The main reason for this is that <code>Bound</code> is a more syntactic representation of bound variables whereas <code>Placeholder</code> is a more semantic representation. As a concrete example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; Other&lt;'a&gt; for &amp;'a u32 { }

impl&lt;T&gt; Trait for T
where
    for&lt;'a&gt; T: Other&lt;'a&gt;,
{ ... }

impl&lt;T&gt; Bar for T
where
    for&lt;'a&gt; &amp;'a T: Trait
{ ... }
<span class="boring">}</span></code></pre></pre>
<p>Given these trait implementations <code>u32: Bar</code> should <em>not</em> hold. <code>&amp;'a u32</code> only implements <code>Other&lt;'a&gt;</code> when the lifetime of the borrow and the lifetime on the trait are equal. However if we only used <code>ReBound</code> and did not have placeholders it may be easy to accidentally believe that trait bound does hold. To explain this let's walk through an example of trying to prove <code>u32: Bar</code> in a world where rustc did not have placeholders:</p>
<ul>
<li>We start by trying to prove <code>u32: Bar</code></li>
<li>We find the <code>impl&lt;T&gt; Bar for T</code> impl, we would wind up instantiating the <code>EarlyBinder</code> with <code>u32</code> (note: this is not <em>quite</em> accurate as we first instantiate the binder with an inference variable that we then infer to be <code>u32</code> but that distinction is not super important here)</li>
<li>There is a where clause <code>for&lt;'a&gt; &amp;'^0 T: Trait</code> on the impl, as we instantiated the early binder with <code>u32</code> we actually have to prove <code>for&lt;'a&gt; &amp;'^0 u32: Trait</code></li>
<li>We find the <code>impl&lt;T&gt; Trait for T</code> impl, we would wind up instantiating the <code>EarlyBinder</code> with <code>&amp;'^0 u32</code></li>
<li>There is a where clause <code>for&lt;'a&gt; T: Other&lt;'^0&gt;</code>, as we instantiated the early binder with <code>&amp;'^0 u32</code> we actually have to prove <code>for&lt;'a&gt; &amp;'^0 u32: Other&lt;'^0&gt;</code></li>
<li>We find the <code>impl&lt;'a&gt; Other&lt;'a&gt; for &amp;'a u32</code> and this impl is enough to prove the bound as the lifetime on the borrow and on the trait are both <code>'^0</code></li>
</ul>
<p>This end result is incorrect as we had two separate binders introducing their own generic parameters, the trait bound should have ended up as something like <code>for&lt;'a1, 'a2&gt; &amp;'^1 u32: Other&lt;'^0&gt;</code> which is <em>not</em> satisfied by the <code>impl&lt;'a&gt; Other&lt;'a&gt; for &amp;'a u32</code>.</p>
<p>While in theory we could make this work it would be quite involved and more complex than the current setup, we would have to:</p>
<ul>
<li>"rewrite" bound variables to have a higher <code>DebruijnIndex</code> whenever instantiating a <code>Binder</code>/<code>EarlyBinder</code> with a <code>Bound</code> ty/const/region</li>
<li>When inferring an inference variable to a bound var, if that bound var is from a binder entered after creating the infer var, we would have to lower the <code>DebruijnIndex</code> of the var.</li>
<li>Separately track what binder an inference variable was created inside of, also what the innermost binder it can name parameters from (currently we only have to track the latter)</li>
<li>When resolving inference variables rewrite any bound variables according to the current binder depth of the infcx</li>
<li>Maybe more (while writing this list items kept getting added so it seems naive to think this is exhaustive)</li>
</ul>
<p>Fundamentally all of this complexity is because <code>Bound</code> ty/const/regions have a different representation for a given parameter on a <code>Binder</code> depending on how many other <code>Binder</code>s there are between the binder introducing the parameter, and its usage. For example given the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;()
where
    for&lt;'a&gt; T: Trait&lt;'a, for&lt;'b&gt; fn(&amp;'b T, &amp;'a u32)&gt;
{ ... }
<span class="boring">}</span></code></pre></pre>
<p>That where clause would be written as:<br />
<code>for&lt;'a&gt; T: Trait&lt;'^0, for&lt;'b&gt; fn(&amp;'^0 T, &amp;'^1_0 u32)&gt;</code><br />
Despite there being two references to the <code>'a</code> parameter they are both represented differently: <code>^0</code> and <code>^1_0</code>, due to the fact that the latter usage is nested under a second <code>Binder</code> for the inner function pointer type.</p>
<p>This is in contrast to <code>Placeholder</code> ty/const/regions which do not have this limitation due to the fact that <code>Universe</code>s are specific to the current <code>InferCtxt</code> not the usage site of the parameter.</p>
<p>It is trivially possible to instantiate <code>EarlyBinder</code>s and unify inference variables with existing <code>Placeholder</code>s as no matter what context the <code>Placeholder</code> is in, it will have the same representation. As an example if we were to instantiate the binder on the higher ranked where clause from above, it would be represented like so:<br />
<code>T: Trait&lt;'!1_0, for&lt;'b&gt; fn(&amp;'^0 T, &amp;'!1_0 u32)&gt;</code><br />
the <code>RePlaceholder</code> representation for both usages of <code>'a</code> are the same despite one being underneath another <code>Binder</code>.</p>
<p>If we were to then instantiate the binder on the function pointer we would get a type such as:<br />
<code>fn(&amp;'!2_0 T, ^'!1_0 u32)</code><br />
the <code>RePlaceholder</code> for the <code>'b</code> parameter is in a higher universe to track the fact that its binder was instantiated after the binder for <code>'a</code>.</p>
<h2 id="instantiating-with-relateparam"><a class="header" href="#instantiating-with-relateparam">Instantiating with <code>ReLateParam</code></a></h2>
<p>As discussed in <a href="param_ty_const_regions.html">the chapter about representing types</a>, <code>RegionKind</code> has two variants for representing generic parameters, <code>ReLateParam</code> and <code>ReEarlyParam</code>.
<code>ReLateParam</code> is conceptually a <code>Placeholder</code> that is always in the root universe (<code>U0</code>). It is used when instantiating late bound parameters of functions/closures while inside of them. Its actual representation is relatively different from both <code>ReEarlyParam</code> and <code>RePlaceholder</code>:</p>
<ul>
<li>A <code>DefId</code> for the item that introduced the late bound generic parameter</li>
<li>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.BoundRegionKind.html"><code>BoundRegionKind</code></a> which either specifies the <code>DefId</code> of the generic parameter and its name (via a <code>Symbol</code>), or that this placeholder is representing the anonymous lifetime of a <code>Fn</code>/<code>FnMut</code> closure's self borrow. There is also a variant for <code>BrAnon</code> but this is not used for <code>ReLateParam</code>.</li>
</ul>
<p>For example, given the following code:</p>
<pre><code class="language-rust ignore">impl Trait for Whatever {
    fn foo&lt;'a&gt;(a: &amp;'a u32) -&gt; &amp;'a u32 {
        let b: &amp;'a u32 = a;
        b
    }
}</code></pre>
<p>the lifetime <code>'a</code> in the type <code>&amp;'a u32</code> in the function body would be represented as:</p>
<pre><code>ReLateParam(
    {impl#0}::foo,
    BoundRegionKind::BrNamed({impl#0}::foo::'a, "'a")
)
</code></pre>
<p>In this specific case of referencing late bound generic parameters of a function from inside the body this is done implicitly during <code>hir_ty_lowering</code> rather than explicitly when instantiating a <code>Binder</code> somewhere. In some cases however, we do explicitly instantiate a <code>Binder</code> with <code>ReLateParam</code>s.</p>
<p>Generally whenever we have a <code>Binder</code> for late bound parameters on a function/closure and we are conceptually inside of the binder already, we use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/context/struct.TyCtxt.html#method.liberate_late_bound_regions"><code>liberate_late_bound_regions</code></a> to instantiate it with <code>ReLateParam</code>s. That makes this operation the <code>Binder</code> equivalent to <code>EarlyBinder</code>'s <code>instantiate_identity</code>.</p>
<p>As a concrete example, accessing the signature of a function we are type checking will be represented as <code>EarlyBinder&lt;Binder&lt;FnSig&gt;&gt;</code>. As we are already "inside" of these binders, we would call <code>instantiate_identity</code> followed by <code>liberate_late_bound_regions</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ty_module/binders.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../early_late_parameters.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ty_module/binders.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../early_late_parameters.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>
        <script src="../pagetoc.js"></script>



    </div>
    </body>
</html>
