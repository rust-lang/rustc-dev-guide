<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pattern and exhaustiveness checking - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/main/src/pat-exhaustive-checking.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pattern-and-exhaustiveness-checking"><a class="header" href="#pattern-and-exhaustiveness-checking">Pattern and exhaustiveness checking</a></h1>
<p>In Rust, pattern matching and bindings have a few very helpful properties. The
compiler will check that bindings are irrefutable when made and that match arms
are exhaustive.</p>
<h2 id="pattern-usefulness"><a class="header" href="#pattern-usefulness">Pattern usefulness</a></h2>
<p>The central question that usefulness checking answers is:
"in this match expression, is that branch redundant?".
More precisely, it boils down to computing whether,
given a list of patterns we have already seen,
a given new pattern might match any new value.</p>
<p>For example, in the following match expression,
we ask in turn whether each pattern might match something
that wasn't matched by the patterns above it.
Here we see the 4th pattern is redundant with the 1st;
that branch will get an "unreachable" warning.
The 3rd pattern may or may not be useful,
depending on whether <code>Foo</code> has other variants than <code>Bar</code>.
Finally, we can ask whether the whole match is exhaustive
by asking whether the wildcard pattern (<code>_</code>)
is useful relative to the list of all the patterns in that match.
Here we can see that <code>_</code> is useful (it would catch <code>(false, None)</code>);
this expression would therefore get a "non-exhaustive match" error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// x: (bool, Option&lt;Foo&gt;)
match x {
    (true, _) =&gt; {} // 1
    (false, Some(Foo::Bar)) =&gt; {} // 2
    (false, Some(_)) =&gt; {} // 3
    (true, None) =&gt; {} // 4
}
<span class="boring">}</span></code></pre></pre>
<p>Thus usefulness is used for two purposes:
detecting unreachable code (which is useful to the user),
and ensuring that matches are exhaustive (which is important for soundness,
because a match expression can return a value).</p>
<h2 id="where-it-happens"><a class="header" href="#where-it-happens">Where it happens</a></h2>
<p>This check is done anywhere you can write a pattern: <code>match</code> expressions, <code>if let</code>, <code>let else</code>,
plain <code>let</code>, and function arguments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `match`
// Usefulness can detect unreachable branches and forbid non-exhaustive matches.
match foo() {
    Ok(x) =&gt; x,
    Err(_) =&gt; panic!(),
}

// `if let`
// Usefulness can detect unreachable branches.
if let Some(x) = foo() {
    // ...
}

// `while let`
// Usefulness can detect infinite loops and dead loops.
while let Some(x) = it.next() {
    // ...
}

// Destructuring `let`
// Usefulness can forbid non-exhaustive patterns.
let Foo::Bar(x, y) = foo();

// Destructuring function arguments
// Usefulness can forbid non-exhaustive patterns.
fn foo(Foo { x, y }: Foo) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="the-algorithm"><a class="header" href="#the-algorithm">The algorithm</a></h2>
<p>Exhaustiveness checking is run before MIR building in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/pattern/check_match/index.html"><code>check_match</code></a>.
It is implemented in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/index.html"><code>rustc_pattern_analysis</code></a> crate,
with the core of the algorithm in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/usefulness/index.html"><code>usefulness</code></a> module.
That file contains a detailed description of the algorithm.</p>
<h2 id="important-concepts"><a class="header" href="#important-concepts">Important concepts</a></h2>
<h3 id="constructors-and-fields"><a class="header" href="#constructors-and-fields">Constructors and fields</a></h3>
<p>In the value <code>Pair(Some(0), true)</code>, <code>Pair</code> is called the constructor of the value, and <code>Some(0)</code> and
<code>true</code> are its fields. Every matchable value can be decomposed in this way. Examples of
constructors are: <code>Some</code>, <code>None</code>, <code>(,)</code> (the 2-tuple constructor), <code>Foo {..}</code> (the constructor for
a struct <code>Foo</code>), and <code>2</code> (the constructor for the number <code>2</code>).</p>
<p>Each constructor takes a fixed number of fields; this is called its arity. <code>Pair</code> and <code>(,)</code> have
arity 2, <code>Some</code> has arity 1, <code>None</code> and <code>42</code> have arity 0. Each type has a known set of
constructors. Some types have many constructors (like <code>u64</code>) or even an infinitely many (like <code>&amp;str</code>
and <code>&amp;[T]</code>).</p>
<p>Patterns are similar: <code>Pair(Some(_), _)</code> has constructor <code>Pair</code> and two fields. The difference is
that we get some extra pattern-only constructors, namely: the wildcard <code>_</code>, variable bindings,
integer ranges like <code>0..=10</code>, and variable-length slices like <code>[_, .., _]</code>. We treat or-patterns
separately.</p>
<p>Now to check if a value <code>v</code> matches a pattern <code>p</code>, we check if <code>v</code>'s constructor matches <code>p</code>'s
constructor, then recursively compare their fields if necessary. A few representative examples:</p>
<ul>
<li><code>matches!(v, _) := true</code></li>
<li><code>matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) &amp;&amp; matches!(v1, p1)</code></li>
<li><code>matches!(Foo { a: v0, b: v1 }, Foo { a: p0, b: p1 }) := matches!(v0, p0) &amp;&amp; matches!(v1, p1)</code></li>
<li><code>matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)</code></li>
<li><code>matches!(Ok(v0), Err(p0)) := false</code> (incompatible variants)</li>
<li><code>matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)</code></li>
<li><code>matches!([v0], [p0, .., p1]) := false</code> (incompatible lengths)</li>
<li><code>matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) &amp;&amp; matches!(v2, p1)</code></li>
</ul>
<p>This concept is absolutely central to pattern analysis. The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/constructor/index.html"><code>constructor</code></a> module provides
functions to extract, list and manipulate constructors. This is a useful enough concept that
variations of it can be found in other places of the compiler, like in the MIR-lowering of a match
expression and in some clippy lints.</p>
<h3 id="constructor-grouping-and-splitting"><a class="header" href="#constructor-grouping-and-splitting">Constructor grouping and splitting</a></h3>
<p>The pattern-only constructors (<code>_</code>, ranges and variable-length slices) each stand for a set of
normal constructors, e.g. <code>_: Option&lt;T&gt;</code> stands for the set {<code>None</code>, <code>Some</code>} and <code>[_, .., _]</code> stands
for the infinite set {<code>[,]</code>, <code>[,,]</code>, <code>[,,,]</code>, ...} of the slice constructors of arity &gt;= 2.</p>
<p>In order to manage these constructors, we keep them as grouped as possible. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (0, false) {
    (0 ..=100, true) =&gt; {}
    (50..=150, false) =&gt; {}
    (0 ..=200, _) =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, all of <code>0</code>, <code>1</code>, .., <code>49</code> match the same arms, and thus can be treated as a group.
In fact, in this match, the only ranges we need to consider are: <code>0..50</code>, <code>50..=100</code>,
<code>101..=150</code>,<code>151..=200</code> and <code>201..</code>. Similarly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Direction { North, South, East, West }
<span class="boring">let wind = (Direction::North, 0u8);
</span>match wind {
    (Direction::North, 50..) =&gt; {}
    (_, _) =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>Here we can treat all the non-<code>North</code> constructors as a group, giving us only two cases to handle:
<code>North</code>, and everything else.</p>
<p>This is called "constructor splitting" and is crucial to having exhaustiveness run in reasonable
time.</p>
<h3 id="usefulness-vs-reachability-in-the-presence-of-empty-types"><a class="header" href="#usefulness-vs-reachability-in-the-presence-of-empty-types">Usefulness vs reachability in the presence of empty types</a></h3>
<p>This is likely the subtlest aspect of exhaustiveness. To be fully precise, a match doesn't operate
on a value, it operates on a place. In certain unsafe circumstances, it is possible for a place to
not contain valid data for its type. This has subtle consequences for empty types. Take the
following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
let x: u8 = 0;
let ptr: *const Void = &amp;x as *const u8 as *const Void;
unsafe {
    match *ptr {
        _ =&gt; println!("Reachable!"),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>ptr</code> is a valid pointer pointing to a place with invalid data. The <code>_</code> pattern
does not look at the contents of the place <code>*ptr</code>, so this code is ok and the arm is taken. In other
words, despite the place we are inspecting being of type <code>Void</code>, there is a reachable arm. If the
arm had a binding however:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span><span class="boring">enum Void {}
</span><span class="boring">let x: u8 = 0;
</span><span class="boring">let ptr: *const Void = &amp;x as *const u8 as *const Void;
</span><span class="boring">unsafe {
</span>match *ptr {
    _a =&gt; println!("Unreachable!"),
}
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Here the binding loads the value of type <code>Void</code> from the <code>*ptr</code> place. In this example, this causes
UB since the data is not valid. In the general case, this asserts validity of the data at <code>*ptr</code>.
Either way, this arm will never be taken.</p>
<p>Finally, let's consider the empty match <code>match *ptr {}</code>. If we consider this exhaustive, then
having invalid data at <code>*ptr</code> is invalid. In other words, the empty match is semantically
equivalent to the <code>_a =&gt; ...</code> match. In the interest of explicitness, we prefer the case with an
arm, hence we won't tell the user to remove the <code>_a</code> arm. In other words, the <code>_a</code> arm is
unreachable yet not redundant. This is why we lint on redundant arms rather than unreachable
arms, despite the fact that the lint says "unreachable".</p>
<p>These considerations only affects certain places, namely those that can contain non-valid data
without UB. These are: pointer dereferences, reference dereferences, and union field accesses. We
track during exhaustiveness checking whether a given place is known to contain valid data.</p>
<p>Having said all that, the current implementation of exhaustiveness checking does not follow the
above considerations. On stable, empty types are for the most part treated as non-empty. The
<a href="https://github.com/rust-lang/rust/issues/51085"><code>exhaustive_patterns</code></a> feature errs on the other end: it allows omitting arms that could be
reachable in unsafe situations. The <a href="https://github.com/rust-lang/rust/issues/118155"><code>never_patterns</code></a> experimental feature aims to fix this and
permit the correct behavior of empty types in patterns.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="effects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="unsafety-checking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="effects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="unsafety-checking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="pagetoc.js"></script>



    </div>
    </body>
</html>
