<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inline assembly - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/main/src/asm.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Inline assembly in rustc mostly revolves around taking an <code>asm!</code> macro invocation and plumbing it
through all of the compiler layers down to LLVM codegen. Throughout the various stages, an
<code>InlineAsm</code> generally consists of 3 components:</p>
<ul>
<li>
<p>The template string, which is stored as an array of <code>InlineAsmTemplatePiece</code>. Each piece
represents either a literal or a placeholder for an operand (just like format strings).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum InlineAsmTemplatePiece {
    String(String),
    Placeholder { operand_idx: usize, modifier: Option&lt;char&gt;, span: Span },
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>The list of operands to the <code>asm!</code> (<code>in</code>, <code>[late]out</code>, <code>in[late]out</code>, <code>sym</code>, <code>const</code>). These are
represented differently at each stage of lowering, but follow a common pattern:</p>
<ul>
<li><code>in</code>, <code>out</code> and <code>inout</code> all have an associated register class (<code>reg</code>) or explicit register
(<code>"eax"</code>).</li>
<li><code>inout</code> has 2 forms: one with a single expression that is both read from and written to, and
one with two separate expressions for the input and output parts.</li>
<li><code>out</code> and <code>inout</code> have a <code>late</code> flag (<code>lateout</code> / <code>inlateout</code>) to indicate that the register
allocator is allowed to reuse an input register for this output.</li>
<li><code>out</code> and the split variant of <code>inout</code> allow <code>_</code> to be specified for an output, which means
that the output is discarded. This is used to allocate scratch registers for assembly code.</li>
<li><code>const</code> refers to an anonymous constants and generally works like an inline const.</li>
<li><code>sym</code> is a bit special since it only accepts a path expression, which must point to a <code>static</code>
or a <code>fn</code>.</li>
</ul>
</li>
<li>
<p>The options set at the end of the <code>asm!</code> macro. The only ones that are of particular interest to
rustc are <code>NORETURN</code> which makes <code>asm!</code> return <code>!</code> instead of <code>()</code>, and <code>RAW</code> which disables format
string parsing. The remaining options are mostly passed through to LLVM with little processing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bitflags::bitflags! {
    pub struct InlineAsmOptions: u16 {
        const PURE = 1 &lt;&lt; 0;
        const NOMEM = 1 &lt;&lt; 1;
        const READONLY = 1 &lt;&lt; 2;
        const PRESERVES_FLAGS = 1 &lt;&lt; 3;
        const NORETURN = 1 &lt;&lt; 4;
        const NOSTACK = 1 &lt;&lt; 5;
        const ATT_SYNTAX = 1 &lt;&lt; 6;
        const RAW = 1 &lt;&lt; 7;
        const MAY_UNWIND = 1 &lt;&lt; 8;
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h2 id="ast"><a class="header" href="#ast">AST</a></h2>
<p><code>InlineAsm</code> is represented as an expression in the AST with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/ast/struct.InlineAsm.html"><code>ast::InlineAsm</code> type</a>.</p>
<p>The <code>asm!</code> macro is implemented in <code>rustc_builtin_macros</code> and outputs an <code>InlineAsm</code> AST node. The
template string is parsed using <code>fmt_macros</code>, positional and named operands are resolved to
explicit operand indices. Since target information is not available to macro invocations,
validation of the registers and register classes is deferred to AST lowering.</p>
<h2 id="hir"><a class="header" href="#hir">HIR</a></h2>
<p><code>InlineAsm</code> is represented as an expression in the HIR with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/hir/struct.InlineAsm.html"><code>hir::InlineAsm</code> type</a>.</p>
<p>AST lowering is where <code>InlineAsmRegOrRegClass</code> is converted from <code>Symbol</code>s to an actual register or
register class. If any modifiers are specified for a template string placeholder, these are
validated against the set allowed for that operand type. Finally, explicit registers for inputs and
outputs are checked for conflicts (same register used for different operands).</p>
<h2 id="type-checking"><a class="header" href="#type-checking">Type checking</a></h2>
<p>Each register class has a whitelist of types that it may be used with. After the types of all
operands have been determined, the <code>intrinsicck</code> pass will check that these types are in the
whitelist. It also checks that split <code>inout</code> operands have compatible types and that <code>const</code>
operands are integers or floats. Suggestions are emitted where needed if a template modifier should
be used for an operand based on the type that was passed into it.</p>
<h2 id="thir"><a class="header" href="#thir">THIR</a></h2>
<p><code>InlineAsm</code> is represented as an expression in the THIR with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/thir/struct.InlineAsmExpr.html"><code>InlineAsmExpr</code> type</a>.</p>
<p>The only significant change compared to HIR is that <code>Sym</code> has been lowered to either a <code>SymFn</code>
whose <code>expr</code> is a <code>Literal</code> ZST of the <code>fn</code>, or a <code>SymStatic</code> which points to the <code>DefId</code> of a
<code>static</code>.</p>
<h2 id="mir"><a class="header" href="#mir">MIR</a></h2>
<p><code>InlineAsm</code> is represented as a <code>Terminator</code> in the MIR with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.TerminatorKind.html#variant.InlineAsm"><code>TerminatorKind::InlineAsm</code> variant</a></p>
<p>As part of THIR lowering, <code>InOut</code> and <code>SplitInOut</code> operands are lowered to a split form with a
separate <code>in_value</code> and <code>out_place</code>.</p>
<p>Semantically, the <code>InlineAsm</code> terminator is similar to the <code>Call</code> terminator except that it has
multiple output places where a <code>Call</code> only has a single return place output.</p>
<h2 id="codegen"><a class="header" href="#codegen">Codegen</a></h2>
<p>Operands are lowered one more time before being passed to LLVM codegen, this is represented by the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/enum.InlineAsmOperandRef.html"><code>InlineAsmOperandRef</code> type</a> from <code>rustc_codegen_ssa</code>.</p>
<p>The operands are lowered to LLVM operands and constraint codes as follows:</p>
<ul>
<li><code>out</code> and the output part of <code>inout</code> operands are added first, as required by LLVM. Late output
operands have a <code>=</code> prefix added to their constraint code, non-late output operands have a <code>=&amp;</code>
prefix added to their constraint code.</li>
<li><code>in</code> operands are added normally.</li>
<li><code>inout</code> operands are tied to the matching output operand.</li>
<li><code>sym</code> operands are passed as function pointers or pointers, using the <code>"s"</code> constraint.</li>
<li><code>const</code> operands are formatted to a string and directly inserted in the template string.</li>
</ul>
<p>The template string is converted to LLVM form:</p>
<ul>
<li><code>$</code> characters are escaped as <code>$$</code>.</li>
<li><code>const</code> operands are converted to strings and inserted directly.</li>
<li>Placeholders are formatted as <code>${X:M}</code> where <code>X</code> is the operand index and <code>M</code> is the modifier
character. Modifiers are converted from the Rust form to the LLVM form.</li>
</ul>
<p>The various options are converted to clobber constraints or LLVM attributes, refer to the
<a href="https://github.com/Amanieu/rfcs/blob/inline-asm/text/0000-inline-asm.md#mapping-to-llvm-ir">RFC</a>
for more details.</p>
<p>Note that LLVM is sometimes rather picky about what types it accepts for certain constraint codes
so we sometimes need to insert conversions to/from a supported type. See the target-specific
ISelLowering.cpp files in LLVM for details of what types are supported for each register class.</p>
<h2 id="adding-support-for-new-architectures"><a class="header" href="#adding-support-for-new-architectures">Adding support for new architectures</a></h2>
<p>Adding inline assembly support to an architecture is mostly a matter of defining the registers and
register classes for that architecture. All the definitions for register classes are located in
<code>compiler/rustc_target/asm/</code>.</p>
<p>Additionally you will need to implement lowering of these register classes to LLVM constraint codes
in <code>compiler/rustc_codegen_llvm/asm.rs</code>.</p>
<p>When adding a new architecture, make sure to cross-reference with the LLVM source code:</p>
<ul>
<li>LLVM has restrictions on which types can be used with a particular constraint code. Refer to the
<code>getRegForInlineAsmConstraint</code> function in <code>lib/Target/${ARCH}/${ARCH}ISelLowering.cpp</code>.</li>
<li>LLVM reserves certain registers for its internal use, which causes them to not be saved/restored
properly around inline assembly blocks. These registers are listed in the <code>getReservedRegs</code>
function in <code>lib/Target/${ARCH}/${ARCH}RegisterInfo.cpp</code>. Any "conditionally" reserved register
such as the frame/base pointer must always be treated as reserved for Rust purposes because we
can't know ahead of time whether a function will require a frame/base pointer.</li>
</ul>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Various tests for inline assembly are available:</p>
<ul>
<li><code>tests/assembly-llvm/asm</code></li>
<li><code>tests/ui/asm</code></li>
<li><code>tests/codegen-llvm/asm-*</code></li>
</ul>
<p>Every architecture supported by inline assembly must have exhaustive tests in
<code>tests/assembly-llvm/asm</code> which test all combinations of register classes and types.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="mir/passes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="cli.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="mir/passes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="cli.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>
        <script src="pagetoc.js"></script>



    </div>
    </body>
</html>
