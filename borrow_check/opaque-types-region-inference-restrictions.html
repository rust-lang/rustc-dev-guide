<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Region inference restrictions - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/main/src/borrow_check/opaque-types-region-inference-restrictions.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="opaque-types-region-inference-restrictions"><a class="header" href="#opaque-types-region-inference-restrictions">Opaque types region inference restrictions</a></h1>
<p>In this chapter we discuss the various restrictions we impose on the generic arguments of
opaque types when defining their hidden types
<code>Opaque&lt;'a, 'b, .., A, B, ..&gt; := SomeHiddenType</code>.</p>
<p>These restrictions are implemented in borrow checking (<a href="https://github.com/rust-lang/rust/blob/435b5255148617128f0a9b17bacd3cc10e032b23/compiler/rustc_borrowck/src/region_infer/opaque_types.rs">Source</a>)
as it is the final step opaque types inference.</p>
<h2 id="background-type-and-const-generic-arguments"><a class="header" href="#background-type-and-const-generic-arguments">Background: type and const generic arguments</a></h2>
<p>For type arguments, two restrictions are necessary: each type argument must be
(1) a type parameter and
(2) is unique among the generic arguments.
The same is applied to const arguments.</p>
<p>Example of case (1):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;X&gt; = impl Sized;

// `T` is a type parameter.
// Opaque&lt;T&gt; := ();
fn good&lt;T&gt;() -&gt; Opaque&lt;T&gt; {}

// `()` is not a type parameter.
// Opaque&lt;()&gt; := ();
fn bad() -&gt; Opaque&lt;()&gt; {} //~ ERROR
<span class="boring">}</span></code></pre></pre>
<p>Example of case (2):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;X, Y&gt; = impl Sized;

// `T` and `U` are unique in the generic args.
// Opaque&lt;T, U&gt; := T;
fn good&lt;T, U&gt;(t: T, _u: U) -&gt; Opaque&lt;T, U&gt; { t }

// `T` appears twice in the generic args.
// Opaque&lt;T, T&gt; := T;
fn bad&lt;T&gt;(t: T) -&gt; Opaque&lt;T, T&gt; { t } //~ ERROR
<span class="boring">}</span></code></pre></pre>
<p><strong>Motivation:</strong> In the first case <code>Opaque&lt;()&gt; := ()</code>, the hidden type is ambiguous because
it is compatible with two different interpretaions: <code>Opaque&lt;X&gt; := X</code> and <code>Opaque&lt;X&gt; := ()</code>.
Similarly for the second case <code>Opaque&lt;T, T&gt; := T</code>, it is ambiguous whether it should be
interpreted as <code>Opaque&lt;X, Y&gt; := X</code> or as <code>Opaque&lt;X, Y&gt; := Y</code>.
Because of this ambiguity, both cases are rejected as invalid defining uses.</p>
<h2 id="uniqueness-restriction"><a class="header" href="#uniqueness-restriction">Uniqueness restriction</a></h2>
<p>Each lifetime argument must be unique in the arguments list and must not be <code>'static</code>.
This is in order to avoid an ambiguity with hidden type inference similar to the case of
type parameters.
For example, the invalid defining use below <code>Opaque&lt;'static&gt; := Inv&lt;'static&gt;</code> is compatible with
both <code>Opaque&lt;'x&gt; := Inv&lt;'static&gt;</code> and <code>Opaque&lt;'x&gt; := Inv&lt;'x&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x&gt; = impl Sized + 'x;
type Inv&lt;'a&gt; = Option&lt;*mut &amp;'a ()&gt;;

fn good&lt;'a&gt;() -&gt; Opaque&lt;'a&gt; { Inv::&lt;'static&gt;::None }

fn bad() -&gt; Opaque&lt;'static&gt; { Inv::&lt;'static&gt;::None }
//~^ ERROR
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x, 'y&gt; = impl Trait&lt;'x, 'y&gt;;

fn good&lt;'a, 'b&gt;() -&gt; Opaque&lt;'a, 'b&gt; {}

fn bad&lt;'a&gt;() -&gt; Opaque&lt;'a, 'a&gt; {}
//~^ ERROR
<span class="boring">}</span></code></pre></pre>
<p><strong>Semantic lifetime equality:</strong>
One complexity with lifetimes compared to type parameters is that
two lifetimes that are syntactically different may be semantically equal.
Therefore, we need to be cautious when verifying that the lifetimes are unique.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is also invalid because `'a` is *semantically* equal to `'static`.
fn still_bad_1&lt;'a: 'static&gt;() -&gt; Opaque&lt;'a&gt; {}
//~^ Should error!

// This is also invalid because `'a` and `'b` are *semantically* equal.
fn still_bad_2&lt;'a: 'b, 'b: 'a&gt;() -&gt; Opaque&lt;'a, 'b&gt; {}
//~^ Should error!
<span class="boring">}</span></code></pre></pre>
<h2 id="an-exception-to-uniqueness-rule"><a class="header" href="#an-exception-to-uniqueness-rule">An exception to uniqueness rule</a></h2>
<p>An exception to the uniqueness rule above is when the bounds at the opaque type's definition require
a lifetime parameter to be equal to another one or to the <code>'static</code> lifetime.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The definition requires `'x` to be equal to `'static`.
type Opaque&lt;'x: 'static&gt; = impl Sized + 'x;

fn good() -&gt; Opaque&lt;'static&gt; {}
<span class="boring">}</span></code></pre></pre>
<p><strong>Motivation:</strong> an attempt to implement the uniqueness restriction for RPITs resulted in a
<a href="https://github.com/rust-lang/rust/pull/112842#issuecomment-1610057887">breakage found by crater</a>.
This can be mitigated by this exception to the rule.
An example of the code that would otherwise break:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Type&lt;'a&gt;(&amp;'a ());
impl&lt;'a&gt; Type&lt;'a&gt; {
    // `'b == 'a`
    fn do_stuff&lt;'b: 'a&gt;(&amp;'b self) -&gt; impl Trait&lt;'a, 'b&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Why this is correct:</strong> for such a defining use like <code>Opaque&lt;'a, 'a&gt; := &amp;'a str</code>,
it can be interpreted in either way—either as <code>Opaque&lt;'x, 'y&gt; := &amp;'x str</code> or as
<code>Opaque&lt;'x, 'y&gt; := &amp;'y str</code> and it wouldn't matter because every use of <code>Opaque</code>
will guarantee that both parameters are equal as per the well-formedness rules.</p>
<h2 id="universal-lifetimes-restriction"><a class="header" href="#universal-lifetimes-restriction">Universal lifetimes restriction</a></h2>
<p>Only universally quantified lifetimes are allowed in the opaque type arguments.
This includes lifetime parameters and placeholders.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x&gt; = impl Sized + 'x;

fn test&lt;'a&gt;() -&gt; Opaque&lt;'a&gt; {
    // `Opaque&lt;'empty&gt; := ()`
    let _: Opaque&lt;'_&gt; = ();
    //~^ ERROR
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Motivation:</strong>
This makes the lifetime and type arguments behave consistently but this is only as a bonus.
The real reason behind this restriction is purely technical, as the <a href="./region_inference/member_constraints.html">member constraints</a> algorithm
faces a fundamental limitation:
When encountering an opaque type definition <code>Opaque&lt;'?1&gt; := &amp;'?2 u8</code>,
a member constraint <code>'?2 member-of ['static, '?1]</code> is registered.
In order for the algorithm to pick the right choice, the <em>complete</em> set of "outlives" relationships
between the choice regions <code>['static, '?1]</code> must already be known <em>before</em> doing the region
inference. This can be satisfied only if each choice region is either:</p>
<ol>
<li>a universal region, i.e. <code>RegionKind::Re{EarlyParam,LateParam,Placeholder,Static}</code>,
because the relations between universal regions are completely known, prior to region inference,
from the explicit and implied bounds.</li>
<li>or an existential region that is "strictly equal" to a universal region.
Strict lifetime equality is defined below and is required here because it is the only type of
equality that can be evaluated prior to full region inference.</li>
</ol>
<p><strong>Strict lifetime equality:</strong>
We say that two lifetimes are strictly equal if there are bidirectional outlives constraints
between them. In NLL terms, this means the lifetimes are part of the same <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">SCC</a>.
Importantly this type of equality can be evaluated prior to full region inference
(but of course after constraint collection).
The other type of equality is when region inference ends up giving two lifetimes variables
the same value even if they are not strictly equal.
See <a href="https://github.com/rust-lang/rust/issues/113971">#113971</a> for how we used to conflate the difference.</p>
<p><strong>interaction with "once modulo regions" restriction</strong>
In the example above, note the opaque type in the signature is <code>Opaque&lt;'a&gt;</code> and the one in the
invalid defining use is <code>Opaque&lt;'empty&gt;</code>.
In the proposed MiniTAIT plan, namely the <a href="https://github.com/rust-lang/rust/pull/116935">"once modulo regions"</a> rule,
we already disallow this.
Although it might appear that "universal lifetimes" restriction becomes redundant as it logically
follows from "MiniTAIT" restrictions, the subsequent related discussion on lifetime equality and
closures remains relevant.</p>
<h2 id="closure-restrictions"><a class="header" href="#closure-restrictions">Closure restrictions</a></h2>
<p>When the opaque type is defined in a closure/coroutine/inline-const body, universal lifetimes that
are "external" to the closure are not allowed in the opaque type arguments.
External regions are defined in <a href="https://github.com/rust-lang/rust/blob/caf730043232affb6b10d1393895998cb4968520/compiler/rustc_borrowck/src/universal_regions.rs#L201."><code>RegionClassification::External</code></a></p>
<p>Example: (This one happens to compile in the current nightly but more practical examples are
already rejected with confusing errors.)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x&gt; = impl Sized + 'x;

fn test&lt;'a&gt;() -&gt; Opaque&lt;'a&gt; {
    let _ = || {
        // `'a` is external to the closure
        let _: Opaque&lt;'a&gt; = ();
        //~^ Should be an error!
    };
    ()
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Motivation:</strong>
In closure bodies, external lifetimes, although being categorized as "universal" lifetimes,
behave more like existential lifetimes in that the relations between them are not known ahead of
time, instead their values are inferred just like existential lifetimes and the requirements are
propagated back to the parent fn. This breaks the member constraints algorithm as described above:</p>
<blockquote>
<p>In order for the algorithm to pick the right choice, the complete set of “outlives” relationships
between the choice regions <code>['static, '?1]</code> must already be known before doing the region inference</p>
</blockquote>
<p>Here is an example that details how :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x, 'y&gt; = impl Sized;

// 
fn test&lt;'a, 'b&gt;(s: &amp;'a str) -&gt; impl FnOnce() -&gt; Opaque&lt;'a, 'b&gt; {
    move || { s }
    //~^ ERROR hidden type for `Opaque&lt;'_, '_&gt;` captures lifetime that does not appear in bounds
}

// The above closure body is desugared into something like:
fn test::{closure#0}(_upvar: &amp;'?8 str) -&gt; Opaque&lt;'?6, '?7&gt; {
    return _upvar
}

// where `['?8, '?6, ?7]` are universal lifetimes *external* to the closure.
// There are no known relations between them *inside* the closure.
// But in the parent fn it is known that `'?6: '?8`.
//
// When encountering an opaque definition `Opaque&lt;'?6, '?7&gt; := &amp;'8 str`,
// The member constraints algorithm does not know enough to safely make `?8 = '?6`.
// For this reason, it errors with a sensible message:
// "hidden type captures lifetime that does not appear in bounds".
<span class="boring">}</span></code></pre></pre>
<p>Without these restrictions, error messages are confusing and, more importantly, there is a risk that
we accept code that would likely break in the future because member constraints are super broken
in closures.</p>
<p><strong>Output types:</strong>
I believe the most common scenario where this causes issues in real-world code is with
closure/async-block output types. It is worth noting that there is a discrepancy between closures
and async blocks that further demonstrates this issue and is attributed to the
<a href="https://github.com/rust-lang/rust/blob/9cf18e98f82d85fa41141391d54485b8747da46f/compiler/rustc_hir_typeck/src/closure.rs#L743">hack of <code>replace_opaque_types_with_inference_vars</code></a>,
which is applied to futures only.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Opaque&lt;'x&gt; = impl Sized + 'x;
fn test&lt;'a&gt;() -&gt; impl FnOnce() -&gt; Opaque&lt;'a&gt; {
    // Output type of the closure is Opaque&lt;'a&gt;
    // -&gt; hidden type definition happens *inside* the closure
    // -&gt; rejected.
    move || {}
    //~^ ERROR expected generic lifetime parameter, found `'_`
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
type Opaque&lt;'x&gt; = impl Sized + 'x;
fn test&lt;'a&gt;() -&gt; impl Future&lt;Output = Opaque&lt;'a&gt;&gt; {
    // Output type of the async block is unit `()`
    // -&gt; hidden type definition happens in the parent fn
    // -&gt; accepted.
    async move {}
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../return-position-impl-trait-in-trait.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../effects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../return-position-impl-trait-in-trait.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../effects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>
        <script src="../pagetoc.js"></script>



    </div>
    </body>
</html>
